# MongoDB Deep Dive

Comprehensive technical guide to MongoDB, a popular NoSQL document database. This document provides detailed technical information, configuration examples, operational procedures, and troubleshooting guides for MongoDB administrators and engineers.

> **For deployment strategies, decision frameworks, and high-level overviews, see the [MongoDB Mastery Series](https://thisiskushal31.github.io/blog/#/blog/mongodb-mastery-series) blog posts.**

## Table of Contents

### Getting Started
- [Overview](#overview)
- [RDBMS vs NoSQL](#rdbms-vs-nosql)
- [Architecture](#architecture)
- [Installation & Configuration](#installation--configuration)

### Data Management
- [Data Types](#data-types)
- [Schema Design](#schema-design)
- [Indexing](#indexing)

### MongoDB Operations
- [Using MongoDB](#using-mongodb)
- [Querying](#querying)
- [Updates](#updates)
- [Deletes](#deletes)
- [Aggregation Pipeline](#aggregation-pipeline)

### Advanced Topics
- [Text Search](#text-search)
- [Geospatial Queries](#geospatial-queries)
- [Transactions](#transactions)
- [Replication](#replication)
- [Sharding](#sharding)
- [Performance Optimization](#performance-optimization)
- [Backup & Recovery](#backup--recovery)
- [Security](#security)
- [Advanced Features](#advanced-features)
- [Best Practices](#best-practices)
- [MongoDB Interview Questions](#mongodb-interview-questions)
- [Resources](#resources)

---

## Overview

MongoDB is a document-oriented NoSQL database that stores data in flexible, JSON-like documents called BSON (Binary JSON). It's designed for scalability and developer productivity.

According to the [MongoDB Documentation](https://docs.mongodb.com/), "MongoDB is a general-purpose, document-based, distributed database built for modern application developers and for the cloud era." MongoDB's flexible schema and horizontal scaling capabilities make it ideal for modern applications with evolving data requirements.

### What is NoSQL?

NoSQL stands for "Not only SQL". NoSQL is a category of databases that stores data in non-relational fashion, meaning NoSQL generally doesn't store data in tables. The name NoSQL is given because in most NoSQL databases, we don't write SQL-like queries for inserting, deleting, updating, and fetching data.

**Types of NoSQL Databases:**
- **Graph Databases**: Neo4j
- **Key-Value Databases**: Redis
- **Document Database**: MongoDB
- **Wide-Column Stores**: Cassandra
- **Time-Series Databases**: InfluxDB

### JSON and BSON

**JSON (JavaScript Object Notation):**
JSON stands for JavaScript Object Notation. It is not actually related to JavaScript - if you make a JSON file, JavaScript can't do much with it directly.

**BSON (Binary JSON):**
MongoDB is a document-based database that internally stores data in the form of BSON (Binary JSON). As developers, we can send or receive data in the form of JSON, and MongoDB automatically manages the conversion between JSON and BSON.

## RDBMS vs NoSQL

When choosing a database for a product, consider both technical and non-technical criteria.

### Non-Technical Criteria

**Querying Interface:**
Every database provides different ways to query data:
- **SQL** in MySQL or PostgreSQL
- **JavaScript object-like syntax** in MongoDB
- **KQL** in Elasticsearch
- **CQL** in Cassandra

**Bulk Processing Support:**
This refers to how easy it is to import/export data or process multiple records together. MongoDB provides tools like `mongoimport` and `mongoexport` for bulk operations.

### Technical Criteria

**Transaction Support:**
- **RDBMS**: Provides excellent transaction support with ACID properties
- **NoSQL**: Transaction support varies (MongoDB supports ACID transactions since version 4.0)

**ACID Support:**

**RDBMS ACID:**
- **A (Atomicity)**: Either the transaction completes all steps, or if something goes wrong, none of them are applied. MySQL achieves this using undo logs.
- **C (Consistency)**: Before and after transaction, data is consistent. Achieved using double write buffer.
- **I (Isolation)**: Transactions execute independently using locks and isolation levels.
- **D (Durability)**: Committed transactions persist using REDO logs.

**NoSQL ACID (Alternative Interpretation):**
- **A (Associative)**: Allows parallel processing by enabling operations to be applied independently.
- **C (Commutative)**: If multiple operations are applied in different orders, the result should be the same.
- **I (Idempotent)**: If an operation is applied multiple times, its effect is only applied once.
- **D (Distributed)**: NoSQL databases support distributed architecture.

**Scaling:**
- **RDBMS**: Vertical scaling (increase server resources)
- **NoSQL**: Horizontal scaling (add more servers)

**Normalization:**
- **RDBMS**: Handles normalization better with joins and relationships
- **NoSQL**: Doesn't have joins, so doesn't handle normalization as well. Uses denormalization for performance.

**Use Case Examples:**

**MongoDB (NoSQL) - Good for:**
- Chat applications (flexible schema, scalable, easy backup using import-export, no strict ACID required)
- Content management systems
- Real-time analytics
- Applications with evolving schemas

**RDBMS (MySQL/PostgreSQL) - Good for:**
- Payment systems (high ACID requirement, transaction capabilities)
- Financial applications
- Applications requiring strict schema
- Systems requiring complex joins and normalization

### Key Features
- **Document Model**: Flexible schema, easy to work with
- **Horizontal Scaling**: Built-in sharding
- **High Availability**: Replica sets with automatic failover
- **Rich Query Language**: Powerful querying and aggregation
- **Indexing**: Secondary indexes for fast queries
- **Transactions**: ACID transactions (since 4.0)

## Architecture

### Components
- **Mongod**: Database server process
- **Mongos**: Query router for sharded clusters
- **Config Servers**: Store metadata for sharded clusters
- **Replica Set**: Group of mongod instances with same data

### Data Model

**MongoDB vs RDBMS Terminology:**

| RDBMS | MongoDB |
|-------|---------|
| Database | Database |
| Table | Collection |
| Row | Document |
| Column | Key (from key-value pair) |
| Primary Key | _id (ObjectId) |
| Foreign Key | Reference (manual) |
| Join | $lookup (aggregation) or application-level |

**How Data is Stored:**

In RDBMS (e.g., MySQL), data is stored in tables. Tables represent real-life entities. Inside a table, we have many rows. Rows represent one data record. Columns inside a table represent properties of the entity.

In MongoDB, we store data in the form of documents (JSON-like). A real-life entity is represented by **Collections**. What a table is for RDBMS, a collection is for MongoDB. In simple terms, collections are groups of JSON documents. One record in a collection is called a **Document**. What a row is for RDBMS, a document is for MongoDB. A document is nothing but a JSON (internally BSON), and a JSON has multiple key-value pairs. The key of JSON represents the property of the entity. So what a column is for RDBMS, a key (from key-value pair) is for MongoDB.

**Document Structure:**
```javascript
// Document structure
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  name: "John Doe",
  email: "john@example.com",
  age: 30,
  address: {
    street: "123 Main St",
    city: "New York",
    zip: "10001"
  },
  tags: ["developer", "mongodb"],
  created_at: ISODate("2024-01-01T00:00:00Z")
}
```

**Flexible Schema:**
Unlike RDBMS where you must define table columns before inserting data, MongoDB doesn't restrict you. Two documents in the same collection can have different properties. This flexibility allows for schema evolution without migrations.

## Installation & Configuration

### Installation

Follow the [official MongoDB installation guide](https://docs.mongodb.com/manual/installation/) to set up MongoDB on your system.

**Ubuntu/Debian:**
```bash
wget -qO - https://www.mongodb.org/static/pgp/server-7.0.asc | sudo apt-key add -
echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/7.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list
sudo apt-get update
sudo apt-get install -y mongodb-org
```

**macOS:**
```bash
brew tap mongodb/brew
brew install mongodb-community
```

**Docker:**
```bash
docker run --name mongodb -d -p 27017:27017 mongo:7.0
```

### Connecting to MongoDB

To connect to MongoDB from your application, you can use the MongoDB Node.js driver or an Object Data Modeling (ODM) library like Mongoose.

#### Using the MongoDB Node.js Driver

```javascript
const { MongoClient } = require("mongodb");

const uri = "mongodb://localhost:27017";
const client = new MongoClient(uri);

async function connectToMongoDB() {
  try {
    await client.connect();
    console.log("Connected to MongoDB!");
    const db = client.db("mydatabase");
    const collection = db.collection("users");
    // Perform operations
  } catch (error) {
    console.error("Connection failed!", error);
  } finally {
    await client.close();
  }
}

connectToMongoDB();
```

#### Using Mongoose

Mongoose is an Object Data Modeling (ODM) library for MongoDB and Node.js. It provides a schema-based solution to model your application data.

**Installation:**
```bash
npm install mongoose
```

**Connection:**
```javascript
const mongoose = require("mongoose");

const uri = "mongodb://localhost:27017/mydatabase";

mongoose
  .connect(uri, { useNewUrlParser: true, useUnifiedTopology: true })
  .then(() => {
    console.log("Connected to MongoDB database!");
  })
  .catch((error) => {
    console.error("Connection failed!", error);
  });
```

**Defining a Schema:**
```javascript
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
    firstName: { type: String, required: true },
    lastName: { type: String, required: true },
    email: { type: String, unique: true, required: true },
    age: { type: Number },
    gender: { type: String, enum: ['Male', 'Female', 'Other'] },
    dateOfBirth: { type: Date },
    address: {
        street: { type: String },
        city: { type: String },
        state: { type: String },
        zipCode: { type: String }
    },
    phoneNumber: { type: String },
    isActive: { type: Boolean, default: true },
    registrationDate: { type: Date, default: Date.now }
});

const Users = mongoose.model('users', userSchema);
module.exports = Users;
```

**Using the Model:**
```javascript
const Users = require('./models/users');

// Create user
const newUser = await Users.create({
    firstName: "John",
    lastName: "Doe",
    email: "john@example.com",
    age: 30
});

// Find users with pagination
const page = 1;
const pageSize = 10;
const users = await Users.find({})
    .skip((page - 1) * pageSize)
    .limit(pageSize);

// Find by ID
const user = await Users.findOne({ _id: userId });

// Update user
const updatedUser = await Users.findOneAndUpdate(
    { _id: userId },
    { age: 31 },
    { new: true }
);

// Delete user
const deletedUser = await Users.findOneAndDelete({ _id: userId });
```

### Configuration
```yaml
# /etc/mongod.conf
storage:
  dbPath: /var/lib/mongodb
  journal:
    enabled: true

systemLog:
  destination: file
  logAppend: true
  path: /var/log/mongodb/mongod.log

net:
  port: 27017
  bindIp: 127.0.0.1

processManagement:
  fork: true
  pidFilePath: /var/run/mongodb/mongod.pid

replication:
  replSetName: rs0

sharding:
  clusterRole: shardsvr
```

## Data Types

### Basic Types
- **String**: UTF-8 strings
- **Integer**: 32-bit or 64-bit integers
- **Double**: 64-bit floating point
- **Boolean**: true/false
- **Date**: Date and time
- **ObjectId**: Unique identifier
- **Null**: Null value

### Complex Types
- **Array**: Ordered list of values
- **Embedded Document**: Nested objects
- **Binary Data**: Binary data (BSON)
- **Regular Expression**: Regex patterns
- **JavaScript**: JavaScript code

## Schema Design

### Collections & Documents
```javascript
// Create collection (implicit)
db.users.insertOne({ name: "John", email: "john@example.com" });

// Explicit collection creation
db.createCollection("users", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "email"],
      properties: {
        name: { bsonType: "string" },
        email: { bsonType: "string", pattern: "^.+@.+$" }
      }
    }
  }
});
```

### Data Modeling Patterns

#### Embedded Documents (1:few)
```javascript
// Good for: Small, related data that's always accessed together
{
  _id: "user123",
  name: "John",
  addresses: [
    { street: "123 Main", city: "NYC" },
    { street: "456 Oak", city: "LA" }
  ]
}
```

#### References (1:many)
```javascript
// Good for: Large documents, many relationships
// User document
{
  _id: "user123",
  name: "John",
  order_ids: ["order1", "order2"]
}

// Order document
{
  _id: "order1",
  user_id: "user123",
  total: 100.00
}
```

## Indexing

Indexing is a mechanism using which a database prepares data structures to store data in a particular order based on particular keys, for faster search.

### Index Types

**Single Field Index:**
```javascript
db.users.createIndex({ email: 1 });  // 1 for ascending, -1 for descending
```

**Compound Index (order matters!):**
```javascript
db.orders.createIndex({ user_id: 1, created_at: -1 });
```

**Text Index:**
```javascript
db.articles.createIndex({ title: "text", content: "text" });
```

**Geospatial Index:**
```javascript
db.places.createIndex({ location: "2dsphere" });
```

**TTL Index (auto-delete after time):**
```javascript
db.sessions.createIndex({ created_at: 1 }, { expireAfterSeconds: 3600 });
```

**Unique Index:**
```javascript
db.users.createIndex({ email: 1 }, { unique: true });
```

**Partial Index:**
```javascript
db.users.createIndex({ email: 1 }, { partialFilterExpression: { status: "active" } });
```

### Index Management

**List all indexes:**
```javascript
db.collection_name.getIndexes();
```

**Create an index:**
```javascript
db.collection_name.createIndex({ field: 1 });
```

**Drop an index:**
```javascript
db.collection_name.dropIndex("index_name");
// or
db.collection_name.dropIndex({ field: 1 });
```

**Rebuild indexes:**
```javascript
db.users.reIndex();
```

### Analyzing Indexes

**Using explain() to analyze queries:**

The `explain()` function helps analyze query performance. Pass `"executionStats"` as an argument to get detailed execution statistics.

```javascript
db.collection_name.find({ filter }).explain("executionStats");
```

**Key metrics to check:**
- **executionTimeMillis**: Time taken to execute query
- **totalKeysExamined**: Number of index keys examined
- **totalDocsExamined**: Number of documents examined
- **nReturned**: Number of documents returned
- **stage**: Query execution stage (COLLSCAN = collection scan, IXSCAN = index scan, FETCH = fetch documents)

**Example - Before Index:**
```javascript
db.weather_data.find({ elevation: { $lt: 8000 } }).explain("executionStats");
// Result: totalDocsExamined: 9991 (scans all documents)
```

**Example - After Index:**
```javascript
// Create index
db.weather_data.createIndex({ elevation: 1 });

// Query again
db.weather_data.find({ elevation: { $lt: 8000 } }).explain("executionStats");
// Result: totalKeysExamined: 6, totalDocsExamined: 6 (uses index efficiently)
```

**Performance Improvement:**
- **Before index**: `docsExamined: 9991` (full collection scan)
- **After index**: `docsExamined: 6` (index scan)
- **Time improvement**: From ~27ms to ~2ms

**Best Practices:**
- Create indexes on fields frequently used in queries
- Monitor `docsExamined` vs `nReturned` ratio (should be close to 1:1)
- Use compound indexes for queries with multiple filter conditions
- Order matters in compound indexes (most selective field first)

## Using MongoDB

### Opening MongoDB Console

**Using mongosh (MongoDB Shell):**
```bash
mongosh
```

**Using MongoDB Compass:**
MongoDB Compass is a GUI tool that provides a visual interface to MongoDB, including the same terminal functionality.

### Database Operations

**List all databases:**
```javascript
show databases;
// or
show dbs;
```

**Select a database:**
```javascript
use database_name;
```

**Note:** The `use` command creates a new database if no database with that name exists, otherwise it selects the existing database. However, if a database is empty (has no collections), it won't appear in `show dbs` output.

**View current database:**
```javascript
db;
```

**Delete database:**
```javascript
db.dropDatabase();
```

**Warning:** This permanently deletes the current database and all its collections!

**List all collections in current database:**
```javascript
show collections;
```

**Note:** Make sure to run `use database_name` first, otherwise no database will be selected.

### Collection Operations

**Create a collection:**
```javascript
db.createCollection("collection_name");
```

**Note:** In MongoDB, you don't need to define the schema (columns) when creating a collection. MongoDB doesn't restrict you - two documents in the same collection can have different properties. This is different from RDBMS where you must define table columns.

**Drop a collection:**
```javascript
db.collection_name.drop();
```

**Warning:** This permanently deletes the collection, all its documents, and all indexes!

**Print all documents in a collection:**
```javascript
db.collection_name.find();

// Prettified output (formatted for readability)
db.collection_name.find().pretty();
```

**Note:** If you have a large amount of data (e.g., 10,000+ documents), `find()` won't print all records at once. It will print some data and then give you a prompt "Type 'it' for more". Type `it` and press Enter to get the next group of data.

**Get count of documents:**
```javascript
// Note: cursor.count() is deprecated
db.collection_name.find().count();

// Use instead:
db.collection_name.estimatedDocumentCount();
// or
db.collection_name.countDocuments({ filter });
```

**Handle large result sets:**
```javascript
// Limit number of documents
db.collection_name.find().limit(10);

// Skip documents (offset)
db.collection_name.find().skip(5).limit(3);
```

### Inserting Data

**Insert a single document:**
```javascript
db.collection_name.insertOne({
    key1: value1,
    key2: value2,
    ...
});
```

**Legacy insert() method (deprecated):**
```javascript
// Note: insert() is deprecated, use insertOne() or insertMany() instead
db.collection_name.insert({
    key1: value1,
    key2: value2
});
```

**Insert multiple documents:**
```javascript
db.collection_name.insertMany([
    {
        key1: value1,
        key2: value2
    },
    {
        key1: value1,
        key2: value2,
        key3: value3
    },
    {
        key5: value5,
        key7: value7
    }
]);
```

**Arrays in documents:**
You can simply use `[]` to add arrays in JSON documents:
```javascript
db.users.insertOne({
    name: "John",
    tags: ["developer", "mongodb", "nodejs"]
});
```

### Importing Data

**Using MongoDB Compass:**
1. Create a new database (can be done directly in Compass)
2. Click "Add Data"
3. Choose "Import JSON or CSV file"
4. Select your JSON file
5. Click "Import"

**Using mongoimport (Command Line):**
```bash
mongoimport --db db_name --collection collection_name --file data.json
```

**Sample datasets:**
You can find free sample MongoDB datasets at: https://github.com/neelabalan/mongodb-sample-dataset

## Querying

### Basic Queries
```javascript
// Find all documents
db.users.find();

// Find with filter
db.users.find({ age: { $gte: 18 } });

// Find one document
db.users.findOne({ email: "john@example.com" });

// Filter records based on condition
db.collection_name.find({ key1: value1, key2: value2 });
```

### Projections

Projections allow you to select specific fields instead of getting all properties. In SQL, this is like using `SELECT name, address FROM TABLE` instead of `SELECT * FROM TABLE`.

**Include specific fields:**
```javascript
// First argument: filter criteria (can be empty object {})
// Second argument: fields to include (set to true)
db.collection_name.find({ filter1: value1 }, { property1: true, property2: true });
```

**Exclude specific fields:**
```javascript
// Exclude fields by setting them to false
db.collection_name.find({}, { property1: false, property2: false });
```

**Example:**
```javascript
// Get only position and visibility fields
db.weather_data.find({}, { position: true, visibility: true });

// Get everything except pastWeatherObservationManual and skyConditionObservation
db.weather_data.find({}, { pastWeatherObservationManual: false, skyConditionObservation: false });
```

### Sorting, Limit, and Skip
```javascript
// Sort
db.users.find().sort({ created_at: -1 });  // -1 for descending, 1 for ascending

// Limit number of documents
db.users.find().limit(10);

// Skip documents (pagination)
db.users.find().skip(20).limit(10);
```

### Get Distinct Values

**Get all distinct values of a particular key:**
```javascript
db.collection_name.distinct("key");
```

**Example:**
```javascript
db.weather_data.distinct("type");
// Returns: ['FM-13', 'SAO']
```

### Query Operators

MongoDB provides different comparison, logical, bitwise, and other operators. To use these operators, instead of directly assigning a key-value pair for filters, put your key and assign it an object. Inside that object, put the operator as the key and the value as the value.

**Syntax:**
```javascript
db.collection_name.find({ property: { $operator: value } });
```

**Commonly Used Operators:**

**Comparison Operators:**
```javascript
// Not equals
db.collection_name.find({ property: { $ne: value } });

// Equals (implicit, but can be explicit)
db.collection_name.find({ property: { $eq: value } });

// Less than
db.collection_name.find({ property: { $lt: value } });

// Less than or equal to
db.collection_name.find({ property: { $lte: value } });

// Greater than
db.collection_name.find({ property: { $gt: value } });

// Greater than or equal to
db.collection_name.find({ property: { $gte: value } });
```

**Logical Operators:**
```javascript
// AND
db.collection_name.find({ $and: [{ key1: value1 }, { key2: value2 }] });

// OR
db.collection_name.find({ $or: [{ key1: value1 }, { key2: value2 }] });

// NOT
db.collection_name.find({ $not: { key: value } });

// NOR (neither condition true)
db.collection_name.find({ $nor: [{ key1: value1 }, { key2: value2 }] });
```

**Array Operators:**
```javascript
// In array - check if property equals any value in array
db.collection_name.find({ property: { $in: [value1, value2, value3] } });

// Not in array
db.collection_name.find({ property: { $nin: [value1, value2] } });

// All - array contains all specified values
db.users.find({ tags: { $all: ["developer", "mongodb"] } });

// Size - array has specific size
db.users.find({ tags: { $size: 3 } });
```

**Element Operators:**
```javascript
// Field exists
db.users.find({ email: { $exists: true } });

// Field type
db.users.find({ tags: { $type: "array" } });
```

**String Operators:**
```javascript
// Regular expression
db.users.find({ email: { $regex: /@gmail\.com$/ } });
```

**Embedded Document Queries:**
```javascript
// Query nested fields using dot notation
db.users.find({ "address.city": "New York" });
```

**Examples:**
```javascript
// Find documents where type is not 'FM-13'
db.weather_data.find({ type: { $ne: 'FM-13' } });

// Find documents where callLetters is in array
db.weather_data.find({ callLetters: { $in: ['VC81', 'VCSZ'] } });

// Complex query with multiple conditions
db.users.find({
    $and: [
        { age: { $gte: 18 } },
        { status: { $in: ["active", "pending"] } }
    ]
});
```

### Updates

Update functions take two arguments:
1. **Filtration criteria**: How to filter what data to update
2. **Update value**: What value to update with

**Update One Document:**
```javascript
db.collection_name.updateOne(
  { filter1: value1 },
  { $operator: { key1: value1, key2: value2 } }
);
```

**Update Many Documents:**
```javascript
db.collection_name.updateMany(
  { filter1: value1 },
  { $operator: { key1: value1, key2: value2 } }
);
```

**Update Operators:**

**$set**: Allocates the value to the key directly
```javascript
db.users.updateOne(
  { email: "john@example.com" },
  { $set: { status: "active" } }
);
```

**$inc**: Increments the value in the key
```javascript
// Increment
db.weather_data.updateOne(
  { _id: ObjectId("...") },
  { $inc: { elevation: 1 } }
);

// Decrement (use negative value)
db.weather_data.updateOne(
  { _id: ObjectId("...") },
  { $inc: { elevation: -1 } }
);
```

**Other Update Operators:**
```javascript
// $push: Add to array
db.users.updateOne(
  { _id: ObjectId("...") },
  { $push: { tags: "new_tag" } }
);

// $pull: Remove from array
db.users.updateOne(
  { _id: ObjectId("...") },
  { $pull: { tags: "old_tag" } }
);

// $unset: Remove field
db.users.updateOne(
  { _id: ObjectId("...") },
  { $unset: { old_field: "" } }
);

// $rename: Rename a field
db.comments.updateOne(
  { name: 'Manthan' },
  { $rename: { mem_since: 'member' } }
);

// Multiple operators
db.users.updateOne(
  { _id: ObjectId("...") },
  { 
    $set: { status: "active" },
    $inc: { login_count: 1 },
    $push: { tags: "new_tag" }
  }
);
```

**findAndModify vs updateOne:**

- **findAndModify()**: Atomically modifies and returns a single document. Use when you need the modified document returned.
- **updateOne()**: Modifies documents without returning them. Use for bulk updates when you don't need the modified document.

**Example:**
```javascript
// findAndModify - returns the modified document
const modified = db.users.findAndModify({
  query: { name: "John" },
  update: { $set: { status: "active" } },
  new: true  // Return the modified document
});

// updateOne - doesn't return the document
db.users.updateOne(
  { name: "John" },
  { $set: { status: "active" } }
);
```

**Replace Document:**
```javascript
db.users.replaceOne(
  { email: "john@example.com" },
  { name: "John", email: "john@example.com", status: "active" }
);
```

**Upsert Option:**
Upsert means "update if exists, insert if not". Use the `upsert: true` option to create a document if no document matches the filter.

```javascript
// Update if exists, insert if not
db.users.updateOne(
  { email: "john@example.com" },
  { $set: { name: "John", email: "john@example.com", status: "active" } },
  { upsert: true }
);

// Example with upsert
db.comments.updateOne(
  { name: 'Manthan' },
  { $set: { name: 'Manthan', lang: 'JavaScript', mem_since: 1 } },
  { upsert: true }
);
```

**Note:** If you use `updateMany`, all records that match the filtration criteria will be updated.

### Deletes

**Delete One Document:**
```javascript
db.collection_name.deleteOne({ filter1: value1, filter2: value2 });
```

**Delete Many Documents:**
```javascript
db.collection_name.deleteMany({ filter1: value1, filter2: value2 });
```

**Find and Delete:**
```javascript
// Find one document matching criteria and delete it
db.collection_name.findOneAndDelete({ filter1: value1 });
```

**Legacy remove() method (deprecated):**
```javascript
// Note: remove() is deprecated, use deleteOne() or deleteMany() instead
db.collection_name.remove({ filter1: value1 });  // Removes all matching documents
db.collection_name.remove({ filter1: value1 }, { justOne: true });  // Removes one document
```

**Difference between drop() and remove():**
- **`db.collection.drop()`**: Deletes the entire collection, including all documents and indexes. The collection no longer exists.
- **`db.collection.remove()`**: Deletes documents matching the query but keeps the collection and indexes. The collection structure remains.

**Examples:**
```javascript
// Delete one document
db.weather_data.deleteOne({ st: 'x-19300+060300' });

// Delete by ObjectId
db.weather_data.deleteOne({ _id: ObjectId("5553a998e4b02cf7151190b9") });

// Delete many documents
db.weather_data.deleteMany({ callLetters: 'FNPG' });
```

## Aggregation Pipeline

MongoDB's Aggregation Framework is a powerful tool for data transformation and analysis. It uses a pipeline of stages to process and aggregate data.

### Pipeline Stages

**Basic Aggregation:**
```javascript
// Basic aggregation
db.orders.aggregate([
  { $match: { status: "completed" } },
  { $group: { 
      _id: "$user_id", 
      total: { $sum: "$amount" },
      count: { $sum: 1 }
    } 
  },
  { $sort: { total: -1 } },
  { $limit: 10 }
]);
```

**Lookup (Join):**
```javascript
// Lookup (join) - performs left outer join
db.orders.aggregate([
  { $lookup: {
      from: "users",
      localField: "user_id",
      foreignField: "_id",
      as: "user"
    }
  },
  { $unwind: "$user" }
]);
```

**Project and Reshape:**
```javascript
// Project and reshape
db.orders.aggregate([
  { $project: {
      user_id: 1,
      total: 1,
      year: { $year: "$created_at" },
      month: { $month: "$created_at" }
    }
  }
]);
```

**Pagination using Aggregation:**
```javascript
// Simple pagination
db.users.aggregate([
  { $skip: (page - 1) * pageSize },
  { $limit: pageSize }
]);

// Pagination with metadata using $facet
db.users.aggregate([
  {
    $facet: {
      metadata: [{ $count: 'totalCount' }],
      data: [
        { $skip: (page - 1) * pageSize },
        { $limit: pageSize },
      ],
    },
  },
]);
```

**Common Aggregation Stages:**
- **$match**: Filter documents (like WHERE in SQL)
- **$group**: Group documents by field and perform aggregations
- **$project**: Reshape documents, add/remove fields
- **$sort**: Sort documents
- **$limit**: Limit number of documents
- **$skip**: Skip documents
- **$lookup**: Join with another collection
- **$unwind**: Deconstruct array fields
- **$facet**: Process multiple pipelines in parallel

**Common Aggregation Stages:**
- **$match**: Filter documents (like WHERE in SQL)
- **$group**: Group documents by field and perform aggregations
- **$project**: Reshape documents, add/remove fields
- **$sort**: Sort documents
- **$limit**: Limit number of documents
- **$skip**: Skip documents
- **$lookup**: Join with another collection
- **$unwind**: Deconstruct array fields
- **$facet**: Process multiple pipelines in parallel

**Pagination using Aggregation:**
```javascript
// Simple pagination
db.users.aggregate([
  { $skip: (page - 1) * pageSize },
  { $limit: pageSize }
]);

// Pagination with metadata using $facet
db.users.aggregate([
  {
    $facet: {
      metadata: [{ $count: 'totalCount' }],
      data: [
        { $skip: (page - 1) * pageSize },
        { $limit: pageSize },
      ],
    },
  },
]);
```

### Aggregation Operators
```javascript
// Arithmetic
{ $add: [ "$price", "$tax" ] }
{ $subtract: [ "$total", "$discount" ] }
{ $multiply: [ "$quantity", "$price" ] }
{ $divide: [ "$total", "$quantity" ] }

// String
{ $concat: [ "$first_name", " ", "$last_name" ] }
{ $toUpper: "$status" }
{ $toLower: "$email" }

// Date
{ $year: "$created_at" }
{ $month: "$created_at" }
{ $dayOfMonth: "$created_at" }

// Conditional
{ $cond: { if: "$is_active", then: "Active", else: "Inactive" } }
```

## Text Search

MongoDB supports full-text search capabilities using text indexes.

**Create Text Index:**
```javascript
// Single field text index
db.articles.createIndex({ content: "text" });

// Multiple fields text index
db.articles.createIndex({ title: "text", content: "text" });
```

**Perform Text Search:**
```javascript
// Search for documents containing the search term
db.articles.find({ $text: { $search: "searchQuery" } });

// Search with language specification
db.articles.find({ $text: { $search: "searchQuery", $language: "en" } });

// Sort by text score
db.articles.find(
  { $text: { $search: "mongodb tutorial" } },
  { score: { $meta: "textScore" } }
).sort({ score: { $meta: "textScore" } });
```

**Text Search Operators:**
- **$search**: The text string to search for
- **$language**: Language for stemming and stop words
- **$caseSensitive**: Case-sensitive search (default: false)
- **$diacriticSensitive**: Diacritic-sensitive search (default: false)

## Geospatial Queries

MongoDB has built-in support for geospatial queries, allowing you to query documents based on their geographical location.

**Create Geospatial Index:**
```javascript
// 2dsphere index (for GeoJSON data)
db.places.createIndex({ location: "2dsphere" });

// 2d index (for legacy coordinate pairs)
db.places.createIndex({ location: "2d" });
```

**Geospatial Query Operators:**
```javascript
// $near - Find documents near a point
db.places.find({
  location: {
    $near: {
      $geometry: { type: "Point", coordinates: [longitude, latitude] },
      $maxDistance: 1000  // in meters
    }
  }
});

// $geoWithin - Find documents within a shape
db.places.find({
  location: {
    $geoWithin: {
      $centerSphere: [[longitude, latitude], radiusInRadians]
    }
  }
});

// $geoIntersects - Find documents that intersect with a shape
db.places.find({
  location: {
    $geoIntersects: {
      $geometry: {
        type: "Polygon",
        coordinates: [[[lng1, lat1], [lng2, lat2], [lng3, lat3], [lng1, lat1]]]
      }
    }
  }
});
```

**Example Document:**
```javascript
{
  _id: ObjectId("..."),
  name: "Central Park",
  location: {
    type: "Point",
    coordinates: [-73.965355, 40.782865]  // [longitude, latitude]
  }
}
```

## Transactions

MongoDB supports multi-document transactions (since version 4.0), allowing multiple operations to be executed atomically.

### Basic Transactions
```javascript
// Start session
const session = db.getMongo().startSession();

// Start transaction
session.startTransaction();

try {
  // Operations within transaction
  db.users.insertOne({ name: "John" }, { session });
  db.orders.insertOne({ user_id: "...", total: 100 }, { session });
  
  // Commit transaction
  session.commitTransaction();
} catch (error) {
  // Rollback on error
  session.abortTransaction();
} finally {
  session.endSession();
}
```

**Transaction in mongosh:**
```javascript
session = db.getMongo().startSession();
session.startTransaction();
try {
  db.collection1.updateOne({ field: value1 }, { $set: { updateField1: newValue1 } }, { session });
  db.collection2.updateOne({ field: value2 }, { $set: { updateField2: newValue2 } }, { session });
  session.commitTransaction();
} catch (error) {
  print("Transaction failed. Aborting...");
  session.abortTransaction();
} finally {
  session.endSession();
}
```

**Transaction Requirements:**
- MongoDB 4.0+ for replica sets
- MongoDB 4.2+ for sharded clusters
- WiredTiger storage engine
- All operations must be on the same session

## Replication

### Replica Set Setup
```javascript
// Initialize replica set
rs.initiate({
  _id: "rs0",
  members: [
    { _id: 0, host: "localhost:27017" },
    { id: 1, host: "localhost:27018" },
    { id: 2, host: "localhost:27019" }
  ]
});

// Check status
rs.status();

// Add member
rs.add("localhost:27020");

// Remove member
rs.remove("localhost:27020");
```

### Read Preferences
```javascript
// Primary (default)
db.users.find().readPref("primary");

// Secondary
db.users.find().readPref("secondary");

// Nearest
db.users.find().readPref("nearest");
```

## Sharding

### Sharded Cluster Setup
```javascript
// Enable sharding
sh.enableSharding("mydb");

// Create shard key
sh.shardCollection("mydb.users", { user_id: 1 });

// Add shard
sh.addShard("rs0/localhost:27017");

// Check shard status
sh.status();
```

### Shard Key Selection
- **High cardinality**: Many unique values
- **Even distribution**: Avoid hotspots
- **Query patterns**: Align with common queries
- **Avoid**: Low cardinality, sequential keys

## Performance Optimization

### Query Optimization
```javascript
// Use explain
db.users.find({ email: "john@example.com" }).explain("executionStats");

// Use indexes
db.users.find({ email: "john@example.com" }).hint({ email: 1 });

// Limit results
db.users.find().limit(100);

// Project only needed fields
db.users.find({}, { name: 1, email: 1 });
```

### Monitoring
```javascript
// Server status
db.serverStatus();

// Current operations
db.currentOp();

// Database stats
db.stats();

// Collection stats
db.users.stats();
```

## Backup & Recovery

### mongodump
```bash
# Full backup
mongodump --uri="mongodb://localhost:27017" --out=/backup

# Single database
mongodump --uri="mongodb://localhost:27017" --db=mydb --out=/backup

# Single collection
mongodump --uri="mongodb://localhost:27017" --db=mydb --collection=users --out=/backup

# With compression
mongodump --uri="mongodb://localhost:27017" --archive=/backup/backup.gz --gzip
```

### mongorestore
```bash
# Restore full backup
mongorestore --uri="mongodb://localhost:27017" /backup

# Restore single database
mongorestore --uri="mongodb://localhost:27017" --db=mydb /backup/mydb

# Restore compressed backup
mongorestore --uri="mongodb://localhost:27017" --archive=/backup/backup.gz --gzip
```

## Security

### Authentication
```javascript
// Create user
use admin
db.createUser({
  user: "admin",
  pwd: "password",
  roles: ["root"]
});

// Authenticate
db.auth("admin", "password");
```

### Authorization
```javascript
// Create read-only user
db.createUser({
  user: "readonly",
  pwd: "password",
  roles: [{ role: "read", db: "mydb" }]
});

// Create application user
db.createUser({
  user: "app",
  pwd: "password",
  roles: [
    { role: "readWrite", db: "mydb" }
  ]
});
```

## Advanced Features

### Capped Collections

A capped collection is a fixed-size collection that automatically overwrites the oldest documents when it reaches its size limit. It is useful for logging and caching scenarios.

**Create Capped Collection:**
```javascript
db.createCollection("logs", {
  capped: true,
  size: 100000,  // Maximum size in bytes
  max: 1000      // Maximum number of documents
});
```

**Characteristics:**
- Fixed size (cannot grow beyond specified size)
- Maintains insertion order
- Automatically removes oldest documents when full
- High performance for insert operations
- No indexes needed (except _id)

**Use Cases:**
- Logging systems
- Real-time analytics
- Caching recent data
- Session storage

### Change Streams

Change streams allow applications to access real-time data changes in a collection, database, or entire deployment. They use the `watch()` method to listen for changes and provide a stream of change events.

**Watch a Collection:**
```javascript
const changeStream = db.collection.watch();

changeStream.on('change', (change) => {
  console.log('Change detected:', change);
  // Handle the change event
});
```

**Change Event Types:**
- **insert**: New document inserted
- **update**: Document updated
- **replace**: Document replaced
- **delete**: Document deleted
- **invalidate**: Change stream invalidated

**Example:**
```javascript
const pipeline = [
  { $match: { 'fullDocument.status': 'active' } }
];

const changeStream = db.users.watch(pipeline);

changeStream.on('change', (change) => {
  if (change.operationType === 'insert') {
    console.log('New user:', change.fullDocument);
  } else if (change.operationType === 'update') {
    console.log('Updated user:', change.documentKey);
  }
});
```

### Storage Engines

**WiredTiger (Default):**
- Default storage engine since MongoDB 3.2
- Better compression, concurrency, and performance
- Uses B-tree and LSM tree structure
- Document-level concurrency control
- Compression reduces storage requirements
- Checkpointing for crash recovery

**MMAPv1 (Deprecated):**
- Older storage engine (removed in MongoDB 4.2)
- Used memory-mapped files
- Collection-level locking
- Less efficient than WiredTiger

**Comparison:**
| Feature | WiredTiger | MMAPv1 |
|---------|------------|--------|
| Concurrency | Document-level | Collection-level |
| Compression | Yes | No |
| Performance | Better | Good |
| Storage | More efficient | Less efficient |

### Write Concern and Read Concern

**Write Concern:**
Write concern specifies the level of acknowledgment requested from MongoDB for write operations. It determines how many members of a replica set must acknowledge a write before it's considered successful.

```javascript
// Acknowledgment from primary only (default)
db.users.insertOne({ name: "John" }, { writeConcern: { w: 1 } });

// Acknowledgment from majority of replica set
db.users.insertOne({ name: "John" }, { writeConcern: { w: "majority" } });

// Acknowledgment from specific number of members
db.users.insertOne({ name: "John" }, { writeConcern: { w: 2 } });

// With timeout
db.users.insertOne({ name: "John" }, { 
  writeConcern: { w: "majority", wtimeout: 5000 } 
});
```

**Read Concern:**
Read concern specifies the consistency and isolation properties of the data read from the database.

```javascript
// Local (default) - Read from primary, may return uncommitted data
db.users.find().readConcern("local");

// Majority - Read only data that has been acknowledged by majority
db.users.find().readConcern("majority");

// Linearizable - Read data that reflects all successful majority-acknowledged writes
db.users.find().readConcern("linearizable");

// Snapshot - Read from a snapshot of majority-committed data
db.users.find().readConcern("snapshot");
```

### Covered Queries

A covered query is a query where all the fields in the query and the returned results are part of an index. It improves performance by avoiding the need to read documents from disk.

**Example:**
```javascript
// Create index
db.users.createIndex({ email: 1, name: 1 });

// Covered query - only uses index, doesn't read documents
db.users.find(
  { email: "john@example.com" },
  { email: 1, name: 1, _id: 0 }  // All fields in index
);

// Not covered - needs to read document for 'age' field
db.users.find(
  { email: "john@example.com" },
  { email: 1, name: 1, age: 1 }  // 'age' not in index
);
```

**Benefits:**
- Faster query execution
- Less I/O (no document reads)
- Lower memory usage
- Better performance for read-heavy workloads

## Best Practices

1. **Schema Design**: Design for access patterns
2. **Indexes**: Create indexes for common queries, monitor index usage
3. **Embed vs Reference**: Embed for 1:few, reference for 1:many
4. **Shard Key**: Choose high cardinality, even distribution
5. **Write Concerns**: Use appropriate write concern for durability
6. **Read Concerns**: Use appropriate read concern for consistency requirements
7. **Connection Pooling**: Use connection pooling in applications
8. **Monitoring**: Monitor performance and resource usage
9. **Backups**: Regular automated backups
10. **Security**: Enable authentication and authorization
11. **Version Control**: Use version control for schema changes
12. **Query Optimization**: Use explain() to analyze queries, use projections
13. **Covered Queries**: Design indexes to support covered queries when possible

## MongoDB Interview Questions

Common MongoDB interview questions and answers:

1. **What is MongoDB? How is it different from SQL databases?**
   - MongoDB is a NoSQL database that stores data in flexible, JSON-like documents. Unlike SQL databases, it does not require a predefined schema and supports horizontal scaling.

2. **What are the key features of MongoDB?**
   - Schema-less, high performance, scalability, flexible data model, rich query language, and support for replication and sharding.

3. **Explain the concept of a document and collection in MongoDB.**
   - A document is a record in MongoDB, stored in BSON format. A collection is a group of documents, similar to a table in SQL databases.

4. **What is BSON in MongoDB?**
   - BSON (Binary JSON) is a binary representation of JSON-like documents, used internally by MongoDB for data storage and transfer.

5. **What is the difference between `find()` and `findOne()`?**
   - `find()` retrieves all documents matching the query, while `findOne()` retrieves only the first matching document.

6. **What are indexes in MongoDB? How do they improve performance?**
   - Indexes are special data structures that store a small portion of the collection's data set in an easy-to-traverse form. They improve query performance by allowing the database to quickly locate and retrieve data.

7. **What is the purpose of the `_id` field in MongoDB?**
   - The `_id` field is a unique identifier for each document in a collection. It ensures that each document can be uniquely identified and retrieved.

8. **Explain the difference between `db.collection.drop()` and `db.collection.remove()`.**
   - `db.collection.drop()` deletes the entire collection, including all documents and indexes. `db.collection.remove()` deletes documents matching the query but keeps the collection and indexes.

9. **What is sharding in MongoDB? Why is it important?**
   - Sharding is the process of distributing data across multiple servers to support horizontal scaling. It is important for handling large datasets and high-throughput applications.

10. **Explain the aggregation framework in MongoDB.**
    - The aggregation framework is a powerful tool for data transformation and analysis. It uses a pipeline of stages, such as `$match`, `$group`, and `$project`, to process and aggregate data.

11. **What are replica sets in MongoDB? How do they ensure high availability?**
    - Replica sets are groups of MongoDB servers that maintain the same data set. They ensure high availability by automatically failing over to a secondary server if the primary server goes down.

12. **What is the difference between embedded and referenced documents?**
    - Embedded documents store related data within a single document, while referenced documents store related data in separate documents and reference them using ObjectIds.

13. **What is a capped collection? When would you use it?**
    - A capped collection is a fixed-size collection that automatically overwrites the oldest documents when it reaches its size limit. It is useful for logging and caching scenarios.

14. **Explain the `$lookup` operator in MongoDB. How does it work?**
    - The `$lookup` operator performs a left outer join to another collection in the same database. It allows you to combine data from multiple collections in a single query.

15. **What is a covered query in MongoDB?**
    - A covered query is a query where all the fields in the query and the returned results are part of an index. It improves performance by avoiding the need to read documents from disk.

16. **Describe MongoDB's internal storage architecture.**
    - MongoDB uses a storage engine (e.g., WiredTiger) to manage data storage. Data is stored in collections, which are composed of documents. Indexes are used to improve query performance.

17. **What are the differences between MongoDB and other NoSQL databases like Cassandra or CouchDB?**
    - MongoDB uses a document-oriented model, while Cassandra uses a wide-column model and CouchDB uses a document model with a focus on replication and synchronization. MongoDB supports rich queries and indexing, while Cassandra excels in write-heavy workloads and CouchDB focuses on offline-first applications.

18. **Explain the write concern and read concern levels in MongoDB.**
    - Write concern specifies the level of acknowledgment requested from MongoDB for write operations. Read concern specifies the consistency and isolation properties of the data read from the database.

19. **What are MongoDB change streams, and how do they work?**
    - Change streams allow applications to access real-time data changes in a collection. They use the `watch()` method to listen for changes and provide a stream of change events.

20. **Describe the WiredTiger storage engine. How does it differ from MMAPv1?**
    - WiredTiger is the default storage engine in MongoDB, offering better compression, concurrency, and performance compared to the older MMAPv1 storage engine. WiredTiger uses a B-tree and LSM tree structure, while MMAPv1 uses memory-mapped files.

21. **How would you secure a MongoDB deployment in production?**
    - Enable authentication, use role-based access control, encrypt data at rest and in transit, configure firewalls, and regularly update MongoDB to the latest version.

22. **What is the difference between `findAndModify()` and `update()`? When would you use one over the other?**
    - `findAndModify()` atomically modifies and returns a single document, while `update()` modifies documents without returning them. Use `findAndModify()` when you need the modified document, and `update()` for bulk updates.

23. **Explain how MongoDB handles concurrency.**
    - MongoDB uses a combination of optimistic and pessimistic concurrency control. It employs document-level locking and supports multi-document transactions to ensure data consistency and isolation.

## Resources

- [MongoDB Documentation](https://docs.mongodb.com/)
- [MongoDB University](https://university.mongodb.com/)
- [MongoDB Blog](https://www.mongodb.com/blog)
- [MongoDB Atlas](https://www.mongodb.com/cloud/atlas) - Cloud-based MongoDB service

